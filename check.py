import pandas as pd
from pathlib import Path
import time
import os

# Clear console for cleaner output
os.system('cls' if os.name == 'nt' else 'clear')

# Paths to CSV files
parser_csv_path = Path("output_icici.csv")       # CSV generated by your parser
reference_csv_path = Path("data/icici/icici_expected.csv")  # Ground truth CSV

# Header box
print("╔" + "═" * 58 + "╗")
print("║ 🕒  Preparing to check and validate your parser output...        ║")
print("╚" + "═" * 58 + "╝\n")

# Validation checklist box
print("📋 Validation Plan:")
print("╔" + "═" * 40 + "╗")
print("║ 1️⃣ Columns — names and order match           ║")
print("║ 2️⃣ Rows — same number of entries              ║")
print("║ 3️⃣ Data types — consistency across both files ║")
print("║ 4️⃣ Values — each cell matches exactly         ║")
print("╚" + "═" * 40 + "╝\n")

# 2-second countdown
for i in range(2, 0, -1):
    print(f"⏳ Starting validation in {i} second(s)...")
    time.sleep(1)

print("\n🚀 Validation process started!\n")

# Step 1 — Load CSVs
print("╔" + "═" * 60 + "╗")
print("║ 🔍 Step 1: Loading CSV files...                                ║")
print("╚" + "═" * 60 + "╝")

df_parser = pd.read_csv(parser_csv_path)
df_reference = pd.read_csv(reference_csv_path)

print(f"✅ Loaded parser CSV: {parser_csv_path} ({len(df_parser)} rows, {len(df_parser.columns)} columns)")
print(f"✅ Loaded reference CSV: {reference_csv_path} ({len(df_reference)} rows, {len(df_reference.columns)} columns)\n")

# Step 2 — Structure validation
print("╔" + "═" * 60 + "╗")
print("║ 🔍 Step 2: Checking basic structure validation...               ║")
print("╚" + "═" * 60 + "╝")

if list(df_parser.columns) == list(df_reference.columns):
    print("✅ Column names match exactly.")
else:
    print("❌ Column names do NOT match.")
    print("   Parser columns:", list(df_parser.columns))
    print("   Reference columns:", list(df_reference.columns))

if len(df_parser) == len(df_reference):
    print("✅ Row counts match.")
else:
    print(f"❌ Row counts differ. Parser: {len(df_parser)}, Reference: {len(df_reference)}")

# Step 3 — Dtype consistency
print("\n╔" + "═" * 60 + "╗")
print("║ 🔍 Step 3: Checking data type consistency...                    ║")
print("╚" + "═" * 60 + "╝")

parser_dtypes = df_parser.dtypes.to_dict()
reference_dtypes = df_reference.dtypes.to_dict()
for col in df_reference.columns:
    if parser_dtypes.get(col) == reference_dtypes.get(col):
        print(f"   ✅ {col}: dtype matches ({parser_dtypes[col]})")
    else:
        print(f"   ❌ {col}: dtype mismatch (Parser: {parser_dtypes.get(col)}, Reference: {reference_dtypes.get(col)})")

# Step 4 — Full equality
print("\n╔" + "═" * 60 + "╗")
print("║ 🔍 Step 4: Checking full DataFrame equality...                  ║")
print("╚" + "═" * 60 + "╝")

if df_parser.equals(df_reference):
    print("✅ Parser output matches the reference CSV exactly!")
else:
    print("❌ Parser output does NOT match the reference CSV.")

    print("\n╔" + "═" * 60 + "╗")
    print("║ 🔍 Step 5: Showing cell-level differences...                    ║")
    print("╚" + "═" * 60 + "╝")

    try:
        comparison_df = df_parser.compare(df_reference)
        print(comparison_df)
        comparison_df.to_csv("csv_differences.csv")
        print("\n💾 Differences saved to csv_differences.csv for review.")
    except ValueError as e:
        print(f"⚠️ Unable to compare directly (possible shape mismatch): {e}")

# Done
print("\n╔" + "═" * 58 + "╗")
print("║ ✅ Validation complete.                                         ║")
print("╚" + "═" * 58 + "╝")
